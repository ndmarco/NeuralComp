# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Construct B-splines
#' 
#' Creates B-spline basis functions evaluated at the time points of interest.
#' 
#' @name GetBSpline
#' @param time Vector of time points of interest
#' @param basis_degree Integer indicating the degree of B-splines
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @returns Matrix containing the B-splines evaluated at the time points of interest
#' 
#' @examples
#' time <- seq(0, 1, 0.01)
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' B <- GetBSpline(time, basis_degree, boundary_knots, internal_knots)
#' 
#' @export
GetBSpline <- function(time, basis_degree, boundary_knots, internal_knots) {
    .Call('_NeuralComp_GetBSpline', PACKAGE = 'NeuralComp', time, basis_degree, boundary_knots, internal_knots)
}

#' Sampler for Drift-Diffusion Competition Model
#' 
#' Conducts MCMC to get posterior samples from the drift-diffusion competition model.
#' This function can fit a time-homogeneous model, as well as a time-inhomogeneous 
#' model.
#' 
#' @name Sampler_Competition
#' @param X_A List of vectors containing the ISIs of A trials
#' @param X_B List of vectors containing the ISIs of B trials
#' @param X_AB List of vectors containing the ISIs of AB trials
#' @param n_A Vector containing number of spikes for each A trial
#' @param n_B Vector containing number of spikes for each B trial
#' @param n_AB Vector containing number of spikes for each AB trial
#' @param MCMC_iters Integer containing the number of MCMC_iterations excluding warm up blocks
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param Warm_block1 Integer containing number of iterations to adapt the leapfrog step size under identity mass matrices
#' @param Warm_block2 Integer containing number of iterations to adapt the mass matrices, leapfrog step size, and delta sampling parameters
#' @param Leapfrog_steps Integer containing number of leapfrog steps per HMC step
#' @param I_A_mean Double containing the value for the mean parameter of IG prior on I_A
#' @param I_A_shape Double containing the value for the shape parameter of IG prior on I_A
#' @param I_B_mean Double containing the value for the mean parameter of IG prior on I_B
#' @param I_B_shape Double containing the value for the shape parameter of IG prior on I_B
#' @param sigma_A_mean Double containing the value for the mean parameter of IG prior on sigma_A
#' @param sigma_A_shape Double containing the value for the shape parameter of IG prior on sigma_A
#' @param sigma_B_mean Double containing the value for the mean parameter of IG prior on sigma_B
#' @param sigma_B_shape Double containing the value for the shape parameter of IG prior on sigma_B
#' @param delta_shape Double containing the value for the shape parameter of gamma prior on delta
#' @param delta_rate Double containing the value for the rate parameter of gamma prior on delta
#' @param step_size_theta Double containing initial leapfrog step size for theta parameters
#' @param step_size_FR Double containing initial leapfrog step size for time-inhomogeneous firing rate parameters
#' @param delta_proposal_mean Double containing the value for mean parameter of the lognormal proposal distribution of delta parameter
#' @param delta_proposal_sd Double containing the value for sd parameter of the lognormal proposal distribution of delta parameter
#' @param alpha_labels Double containing probability that proposed new deltas come from the prior on delta instead of adapted lognormal distribution
#' @param alpha Double containing the value for the shape parameter of the inverse gamma prior on I_A_sigma squared and I_B_sigma squared
#' @param beta Double containing the value for the scale parameter of the inverse gamma prior on I_A_sigma squared and I_B_sigma squared
#' @param delta_adaptation_block Integer containing how often the delta sampling parameters should be updated in Warm_block2
#' @param Mass_adaptation_block Integer containing how often the Mass Matrix should be updated in Warm_block2
#' @param M_proposal Integer containing the number of deltas proposed when sampling delta
#' @returns List containing:
#' \describe{
#'   \item{\code{theta}}{Matrix of samples of the theta parameters (I_A, I_B, sigma_A, sigma_B, delta) where each row is an MCMC sample}
#'   \item{\code{labels}}{List of matrices where each item in the list contains MCMC samples from an AB trial}
#'   \item{\code{basis_coef_A}}{Matrix containing MCMC samples of the coefficients of the B-splines for the A process (if time-inhomogeneous)}
#'   \item{\code{basis_coef_B}}{Matrix containing MCMC samples of the coefficients of the B-splines for the B process (if time-inhomogeneous)}
#'   \item{\code{I_A_sigma_sq}}{Vector of MCMC samples of I_A_sigma squared}
#'   \item{\code{I_B_sigma_sq}}{Vector of MCMC samples of I_B_sigma squared}
#'   \item{\code{LogLik}}{Log-likelihood for each MCMC iteration}
#'   \item{\code{LogPosterior}}{Log-Posterior for each MCMC iteration}
#'   
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{I_A_mean}}{must be greater than 0}
#'   \item{\code{I_A_shape}}{must be greater than 0}
#'   \item{\code{I_B_mean}}{must be greater than 0}
#'   \item{\code{I_B_shape}}{must be greater than 0}
#'   \item{\code{sigma_A_mean}}{must be greater than 0}
#'   \item{\code{sigma_A_shape}}{must be greater than 0}
#'   \item{\code{sigma_B_mean}}{must be greater than 0}
#'   \item{\code{sigma_B_shape}}{must be greater than 0}
#'   \item{\code{delta_shape}}{must be greater than 0}
#'   \item{\code{delta_rate}}{must be greater than 0}
#'   \item{\code{step_size_theta}}{must be greater than 0}
#'   \item{\code{step_size_FR}}{must be greater than 0}
#'   \item{\code{delta_proposal_sd}}{must be greater than 0}
#'   \item{\code{alpha_labels}}{must be between 0 and 1}
#'   \item{\code{alpha}}{must be greater than 0}
#'   \item{\code{beta}}{must be greater than 0}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                                time_inhomogeneous = FALSE)
#' 
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#' 
#' @export
Sampler_Competition <- function(X_A, X_B, X_AB, n_A, n_B, n_AB, MCMC_iters, basis_degree, boundary_knots, internal_knots, time_inhomogeneous = TRUE, Warm_block1 = 500L, Warm_block2 = 2000L, Leapfrog_steps = 10L, I_A_mean = 40, I_A_shape = 1, I_B_mean = 40, I_B_shape = 1, sigma_A_mean = 6.32, sigma_A_shape = 1, sigma_B_mean = 6.32, sigma_B_shape = 1, delta_shape = 0.01, delta_rate = 0.1, step_size_theta = 0.001, step_size_FR = 0.001, delta_proposal_mean = -2, delta_proposal_sd = 0.3, alpha_labels = 0.2, nu = 5, gamma = 2, delta_adaption_block = 100L, Mass_adaption_block = 500L, M_proposal = 10L) {
    .Call('_NeuralComp_Sampler_Competition', PACKAGE = 'NeuralComp', X_A, X_B, X_AB, n_A, n_B, n_AB, MCMC_iters, basis_degree, boundary_knots, internal_knots, time_inhomogeneous, Warm_block1, Warm_block2, Leapfrog_steps, I_A_mean, I_A_shape, I_B_mean, I_B_shape, sigma_A_mean, sigma_A_shape, sigma_B_mean, sigma_B_shape, delta_shape, delta_rate, step_size_theta, step_size_FR, delta_proposal_mean, delta_proposal_sd, alpha_labels, nu, gamma, delta_adaption_block, Mass_adaption_block, M_proposal)
}

#' Sampler for IIGPP model
#' 
#' Conducts MCMC to get posterior samples from an (inhomogeneous) inverse Gaussian point process.
#' This function can fit a time-homogeneous model, as well as a time-inhomogeneous 
#' model.
#' 
#' @name Sampler_IIGPP
#' @param X List of vectors containing the ISIs the trials
#' @param n Vector containing number of spikes for the trials
#' @param MCMC_iters Integer containing the number of MCMC_iterations excluding warm up blocks
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param Warm_block1 Integer containing number of iterations to adapt the leapfrog step size under identity mass matrices
#' @param Warm_block2 Integer containing number of iterations to adapt the mass matrices, leapfrog step size, and delta sampling parameters
#' @param Leapfrog_steps Integer containing number of leapfrog steps per HMC step
#' @param I_mean Double containing the value for the mean parameter of IG prior on I
#' @param I_shape Double containing the value for the shape parameter of IG prior on I
#' @param sigma_mean Double containing the value for the mean parameter of IG prior on sigma
#' @param sigma_shape Double containing the value for the shape parameter of IG prior on sigma
#' @param step_size_theta Double containing initial leapfrog step size for theta parameters
#' @param step_size_FR Double containing initial leapfrog step size for time-inhomogeneous firing rate parameters
#' @param alpha Double containing the value for the shape parameter of the inverse gamma prior on I_A_sigma squared and I_B_sigma squared
#' @param beta Double containing the value for the scale parameter of the inverse gamma prior on I_A_sigma squared and I_B_sigma squared
#' @param Mass_adaptation_block Integer containing how often the Mass Matrix should be updated in Warm_block2
#' @param M_proposal Integer containing the number of deltas proposed when sampling delta
#' @returns List containing:
#' \describe{
#'   \item{\code{theta}}{Matrix of samples of the theta parameters (I, sigma) where each row is an MCMC sample}
#'   \item{\code{basis_coef}}{Matrix containing MCMC samples of the coefficients of the B-splines for the inhomogeneous process (if time-inhomogeneous)}
#'   \item{\code{I_sigma_sq}}{Vector of MCMC samples of I_sigma squared}
#'   \item{\code{LogLik}}{Log-likelihood for each MCMC iteration}
#'   \item{\code{LogPosterior}}{Log-Posterior for each MCMC iteration}
#'   
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{I_mean}}{must be greater than 0}
#'   \item{\code{I_shape}}{must be greater than 0}
#'   \item{\code{sigma_mean}}{must be greater than 0}
#'   \item{\code{sigma_shape}}{must be greater than 0}
#'   \item{\code{step_size_theta}}{must be greater than 0}
#'   \item{\code{step_size_FR}}{must be greater than 0}
#'   \item{\code{delta_proposal_sd}}{must be greater than 0}
#'   \item{\code{alpha}}{must be greater than 0}
#'   \item{\code{beta}}{must be greater than 0}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                          internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                          time_inhomogeneous = FALSE)
#' 
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots, 
#'                          internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#' 
#' @export
Sampler_IIGPP <- function(X, n, MCMC_iters, basis_degree, boundary_knots, internal_knots, time_inhomogeneous = TRUE, Warm_block1 = 500L, Warm_block2 = 2000L, Leapfrog_steps = 10L, I_mean = 40, I_shape = 1, sigma_mean = 6.32, sigma_shape = 1, step_size_theta = 0.001, step_size_FR = 0.001, nu = 5, gamma = 2, Mass_adaption_block = 500L, M_proposal = 10L) {
    .Call('_NeuralComp_Sampler_IIGPP', PACKAGE = 'NeuralComp', X, n, MCMC_iters, basis_degree, boundary_knots, internal_knots, time_inhomogeneous, Warm_block1, Warm_block2, Leapfrog_steps, I_mean, I_shape, sigma_mean, sigma_shape, step_size_theta, step_size_FR, nu, gamma, Mass_adaption_block, M_proposal)
}

#' Constructs CI for IIGPP Firing Rate
#' 
#' Constructs credible intervals for the time-inhomgeneous mean parameter (I) of the inhomogeneous
#' inverse Gaussian point process.
#' 
#' @name FR_CI_IIGPP
#' @param time Vector of time points at which pointwise credible intervals will be constructed
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param Results List produced from running \code{Sampler_IGP}
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in
#' @param alpha Double indicating the size of the credible interval ((1 - alpha) * 100 percent)
#' 
#' @returns List containing:
#' \describe{
#'   \item{\code{FR_MCMC_Samps}}{Matrix of MCMC samples of the firing rate at the specified time points}
#'   \item{\code{FR_CI}}{Matrix containing the upper and lower values of the credible interval at the specified time points (first column is lower value, second column is upper value)}
#'   \item{\code{FR_Median}}{Vector containing the estimated posterior median at the specified time points}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{alpha}}{must be between 0 and 0.5}
#' }
#' 
#' @examples
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#' 
#' ## Get CI
#' time <- seq(0, 1, 0.01)
#' CI <- FR_CI_IIGPP(time, basis_degree, boundary_knots, internal_knots, results)
#' 
#' @export
FR_CI_IIGPP <- function(time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop = 0.3, alpha = 0.05) {
    .Call('_NeuralComp_FR_CI_IIGPP', PACKAGE = 'NeuralComp', time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop, alpha)
}

FR_CI_Competition <- function(time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop = 0.3, alpha = 0.05) {
    .Call('_NeuralComp_FR_CI_Competition', PACKAGE = 'NeuralComp', time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop, alpha)
}

#' Calculates WAIC for the Competition Model (Conditional)
#' 
#' This function calculates the Watanabe-Akaike information criterion (WAIC) for 
#' the drift-diffusion competition model using the conditional likelihood. This function will use the output from
#' \code{Sampler_Competition}. The WAIC is defined on the deviance scale as waic = -2(lppd - p),
#' where lppd is the log pointwise predictive density, and p is the effective number of parameters.
#' The WAIC can be calculated using four different ways, as specified in the supplemental materials
#' of the accompanying manuscript. The conditional WAIC is akin to leave-one-spike-out cross validation (asymptotically).
#' 
#' @name WAIC_Competition
#' @param X_A List of vectors containing the ISIs of A trials
#' @param X_B List of vectors containing the ISIs of B trials
#' @param X_AB List of vectors containing the ISIs of AB trials
#' @param n_A Vector containing number of spikes for each A trial
#' @param n_B Vector containing number of spikes for each B trial
#' @param n_AB Vector containing number of spikes for each AB trial
#' @param Results List produced from running \code{Sampler_Competition}
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param method String containing method used to calculate WAIC (sampling, sampling_fast, numerical_approx, marginal)
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @param max_time Double containing parameter for estimating the probability of switching states used only for numerical_approx method (max_time should be large enough so that the probability of observing an ISI greater than this is negligible) 
#' @param n_eval Integer containing parameter for estimating the probability of switching states used only for numerical_approx method (the larger the number the more computationally expensive, but more accurate)
#' @param n_MCMC_approx number of y_tilde samples drawn when using sampling method (denoted M_Y_tilde in the manuscript)
#' @param n_MCMC_approx2 number of x_tilde samples drawn when using sampling method (denoted M_X_tilde in the manuscript)
#' @returns List containing:
#' \describe{
#'   \item{\code{WAIC}}{Estimate of WAIC}
#'   \item{\code{LPPD}}{Estimate of LPPD}
#'   \item{\code{Effective_pars}}{Estimated Effective number of parameters}
#'   \item{\code{llik_A}}{Log-likelihood for A trial spike trains}
#'   \item{\code{llik_B}}{Log-likelihood for B trial spike trains}
#'   \item{\code{llik_AB}}{Log-likelihood for AB trial spike trains}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                                time_inhomogeneous = FALSE)
#'                                
#' ## Calculate WAIC
#' WAIC <- WAIC_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB,
#'                          results, basis_degree, boundary_knots, internal_knots,
#'                          time_inhomogeneous = FALSE)
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#' 
#' ## Calculate WAIC
#' WAIC <- WAIC_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB,
#'                        results, basis_degree, boundary_knots, internal_knots)
#' 
#' @export
WAIC_Competition <- function(X_A, X_B, X_AB, n_A, n_B, n_AB, Results, basis_degree, boundary_knots, internal_knots, time_inhomogeneous = TRUE, method = "sampling_fast", burnin_prop = 0.5, max_time = 2, n_spike_evals = 25, n_eval = 3000L, n_MCMC_approx = 5L, n_MCMC_approx2 = 30L, n_MCMC_approx_fast = 100L, n_samples_var = 2L) {
    .Call('_NeuralComp_WAIC_Competition', PACKAGE = 'NeuralComp', X_A, X_B, X_AB, n_A, n_B, n_AB, Results, basis_degree, boundary_knots, internal_knots, time_inhomogeneous, method, burnin_prop, max_time, n_spike_evals, n_eval, n_MCMC_approx, n_MCMC_approx2, n_MCMC_approx_fast, n_samples_var)
}

#' Calculates WAIC for the Competition Model (Marginal)
#' 
#' This function calculates the Watanabe-Akaike information criterion (WAIC) for 
#' the drift-diffusion competition model using the marginal likelihood (marginalizing out the labels).
#'  This function will use the output from 
#' \code{Sampler_Competition}. The WAIC is defined on the deviance scale as waic = -2(lppd - p),
#' where lppd is the log pointwise predictive density, and p is the effective number of parameters.
#' The Marginal WAIC is akin to leave-one-spike-train-out cross validation (asymptotically).
#' 
#' @name WAIC_Competition_Marginal
#' @param X_A List of vectors containing the ISIs of A trials
#' @param X_B List of vectors containing the ISIs of B trials
#' @param X_AB List of vectors containing the ISIs of AB trials
#' @param n_A Vector containing number of spikes for each A trial
#' @param n_B Vector containing number of spikes for each B trial
#' @param n_AB Vector containing number of spikes for each AB trial
#' @param Results List produced from running \code{Sampler_Competition}
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @returns List containing:
#' \describe{
#'   \item{\code{WAIC}}{Estimate of WAIC}
#'   \item{\code{LPPD}}{Estimate of LPPD}
#'   \item{\code{Effective_pars}}{Estimated Effective number of parameters}
#'   \item{\code{llik_A}}{Log-likelihood for A trial spike trains}
#'   \item{\code{llik_B}}{Log-likelihood for B trial spike trains}
#'   \item{\code{llik_AB}}{Log-likelihood for AB trial spike trains}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                                time_inhomogeneous = FALSE)
#'                                
#' ## Calculate WAIC
#' WAIC <- WAIC_Competition_Marginal(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB,
#'                                   results, basis_degree, boundary_knots, internal_knots,
#'                                   time_inhomogeneous = FALSE)
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#' 
#' ## Calculate WAIC
#' WAIC <- WAIC_Competition_Marginal(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB,
#'                                   results, basis_degree, boundary_knots, internal_knots)
#' 
#' @export
WAIC_Competition_Marginal <- function(X_A, X_B, X_AB, n_A, n_B, n_AB, Results, basis_degree, boundary_knots, internal_knots, method = "Spike", time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_WAIC_Competition_Marginal', PACKAGE = 'NeuralComp', X_A, X_B, X_AB, n_A, n_B, n_AB, Results, basis_degree, boundary_knots, internal_knots, method, time_inhomogeneous, burnin_prop)
}

#' Calculates WAIC for the IIGPP Model
#' 
#' This function calculates the Watanabe-Akaike information criterion (WAIC) for 
#' the (inhomogeneous) inverse Gaussian point process. This function will use the output from
#' \code{Sampler_IGP} fit for the A, B, and AB data. The WAIC is defined on the 
#' deviance scale as waic = -2(lppd - p), where lppd is the log pointwise 
#' predictive density, and p is the effective number of parameters.
#' 
#' @name WAIC_IIGPP
#' @param X_A List of vectors containing the ISIs of A trials
#' @param X_B List of vectors containing the ISIs of B trials
#' @param X_AB List of vectors containing the ISIs of AB trials
#' @param n_A Vector containing number of spikes for each A trial
#' @param n_B Vector containing number of spikes for each B trial
#' @param n_AB Vector containing number of spikes for each AB trial
#' @param Results_A List produced from running \code{Sampler_IIGPP} for A trials
#' @param Results_B List produced from running \code{Sampler_IIGPP} for B trials
#' @param Results_AB List produced from running \code{Sampler_IIGPP} for AB trials
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @returns List containing:
#' \describe{
#'   \item{\code{WAIC}}{Estimate of WAIC}
#'   \item{\code{LPPD}}{Estimate of LPPD}
#'   \item{\code{Effective_pars}}{Estimated Effective number of parameters}
#'   \item{\code{llik_A}}{Log-likelihood for A trial spike trains}
#'   \item{\code{llik_B}}{Log-likelihood for B trial spike trains}
#'   \item{\code{llik_AB}}{Log-likelihood for AB trial spike trains}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain for A trials
#' results_A <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                            internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                            time_inhomogeneous = FALSE)
#'                        
#' ## Run MCMC chain for B trials
#' results_B<- Sampler_IIGPP(dat$X_B, dat$n_B, MCMC_iters, basis_degree, boundary_knots,
#'                           internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                           time_inhomogeneous = FALSE)
#'
#' ## Run MCMC chain for AB trials
#' results_AB <- Sampler_IIGPP(dat$X_AB, dat$n_AB, MCMC_iters, basis_degree, boundary_knots,
#'                             internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                             time_inhomogeneous = FALSE)         
#' ## Calculate WAIC
#' WAIC <- WAIC_IIGPP(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, results_A,
#'                    results_B, results_AB, basis_degree, boundary_knots, internal_knots,
#'                    time_inhomogeneous = FALSE)
#' 
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain for A trials
#' results_A <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                            internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#'                        
#' ## Run MCMC chain for B trials
#' results_B<- Sampler_IIGPP(dat$X_B, dat$n_B, MCMC_iters, basis_degree, boundary_knots,
#'                           internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#'
#' ## Run MCMC chain for AB trials
#' results_AB <- Sampler_IIGPP(dat$X_AB, dat$n_AB, MCMC_iters, basis_degree, boundary_knots,
#'                             internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#'
#' WAIC <- WAIC_IIGPP(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, results_A,
#'                    results_B, results_AB, basis_degree, boundary_knots, internal_knots)
#' 
#' @export
WAIC_IIGPP <- function(X_A, X_B, X_AB, n_A, n_B, n_AB, Results_A, Results_B, Results_AB, basis_degree, boundary_knots, internal_knots, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_WAIC_IIGPP', PACKAGE = 'NeuralComp', X_A, X_B, X_AB, n_A, n_B, n_AB, Results_A, Results_B, Results_AB, basis_degree, boundary_knots, internal_knots, time_inhomogeneous, burnin_prop)
}

WAIC_Winner_Take_All <- function(X_A, X_B, n_A, n_B, Results_A, Results_B, basis_degree, boundary_knots, internal_knots, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_WAIC_Winner_Take_All', PACKAGE = 'NeuralComp', X_A, X_B, n_A, n_B, Results_A, Results_B, basis_degree, boundary_knots, internal_knots, time_inhomogeneous, burnin_prop)
}

#' Posterior Predictive Sampling for Competition Model
#' 
#' This function generates posterior predictive samples of scientific interest from
#' the competition model. Specifically, this function allows you to obtain (1) posterior
#' predictive samples from the A condition, B condition, and AB conditions (2) posterior
#' predictive samples of spike counts under the A condition, B condition, and AB conditions, 
#' (3) posterior predictive samples of time spent encoding each state (4) posterior predictive 
#' samples for the number of switches in a trial. This function is to be used after running
#' \code{Sampler_Competition}.
#' 
#' @name Competition_Posterior_Predictive
#' @param trial_time Double containing length of trial to simulate
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param Results List produced from running \code{Sampler_Competition}
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param n_samples Integer containing number of posterior predictive samples to generate
#' @returns List containing:
#' \describe{
#'   \item{\code{posterior_pred_samples_A}}{Posterior predictive samples of spike trains under the A stimulus}
#'   \item{\code{posterior_pred_samples_B}}{Posterior predictive samples of spike trains under the B stimulus}
#'   \item{\code{posterior_pred_samples_AB}}{Posterior predictive samples of spike trains under the A  and B stimuli}
#'   \item{\code{posterior_pred_labels}}{labels corresponding to posterior_pred_samples_AB}
#'   \item{\code{n_A}}{Number of spikes in each of the spike trains in posterior_pred_samples_A}
#'   \item{\code{n_B}}{Number of spikes in each of the spike trains in posterior_pred_samples_B}
#'   \item{\code{n_AB}}{Number of spikes in each of the spike trains in posterior_pred_samples_AB}
#'   \item{\code{switch_times}}{Times spent in each encoding state in the spike trains generated in posterior_pred_samples_AB}
#'   \item{\code{switch_states}}{Encoding state (labels) corresponding to switch_times}
#'   \item{\code{n_switches}}{number of switches observed in each spike train generated in posterior_pred_samples_AB}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{n_sample}}{must be greater than 1}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                                time_inhomogeneous = FALSE)
#'                                
#' ## Posterior Predictive Samples
#' post_pred <- Competition_Posterior_Predictive(1, basis_degree, boundary_knots, internal_knots,
#'                                               results, time_inhomogeneous = FALSE)
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#'                                
#' ## Posterior Predictive Samples                               
#' post_pred <- Competition_Posterior_Predictive(1, basis_degree, boundary_knots, internal_knots,
#'                                               results)
#'                                               
#' @export
Competition_Posterior_Predictive <- function(trial_time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop = 0.2, time_inhomogeneous = TRUE, n_samples = 10000L) {
    .Call('_NeuralComp_Competition_Posterior_Predictive', PACKAGE = 'NeuralComp', trial_time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop, time_inhomogeneous, n_samples)
}

#' Estimate the KL Divergence Between the A and B Point Processes
#' 
#' This function estimates the KL Divergence between the point process 
#' specified for the A stimulus and B stimulus. This can be useful when determining
#' whether or not the responses to the two stimuli are sufficiently different. The KL
#' divergence is approximated using a finite grid of points over the trial-time
#' 
#' @name KL_divergence_A_B
#' @param Results_A List produced from running \code{Sampler_IIGPP} for A trials
#' @param Results_B List produced from running \code{Sampler_IIGPP} for B trials
#' @param time_grid Vector of time points that create a dense-grid over the trial-time
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param Results List produced from running \code{Sampler_Competition}
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param n_MC_samples Integer containing number of samples used to estimate the KL-divergence at each time point
#' @returns KL_divergence Approximation of the KL Divergence
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{n_sample}}{must be greater than 1}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain for A trials
#' results_A <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                            internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                            time_inhomogeneous = FALSE)
#'                        
#' ## Run MCMC chain for B trials
#' results_B<- Sampler_IIGPP(dat$X_B, dat$n_B, MCMC_iters, basis_degree, boundary_knots,
#'                           internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                           time_inhomogeneous = FALSE)
#'                                
#' ## Calculate KL Divergence between distribution of A spike train and distribution of 
#' ## B spike train
#' time_grid <- seq(0, 1, 0.01)
#' KL_div <- KL_divergence_A_B(results_A, results_B, time_grid, basis_degree, 
#'                             boundary_knots, internal_knots, time_inhomogeneous = FALSE)
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain for A trials
#' results_A <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                            internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#'                        
#' ## Run MCMC chain for B trials
#' results_B<- Sampler_IIGPP(dat$X_B, dat$n_B, MCMC_iters, basis_degree, boundary_knots,
#'                           internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#'                                
#' ## Calculate KL Divergence between distribution of A spike train and distribution of 
#' ## B spike train
#' time_grid <- seq(0, 1, 0.01)
#' KL_div <- KL_divergence_A_B(results_A, results_B, time_grid, basis_degree, 
#'                             boundary_knots, internal_knots)
#'                                               
#' @export
KL_divergence_A_B <- function(Results_A, Results_B, time_grid, basis_degree, boundary_knots, internal_knots, burnin_prop = 0.2, time_inhomogeneous = TRUE, n_MC_samples = 10L) {
    .Call('_NeuralComp_KL_divergence_A_B', PACKAGE = 'NeuralComp', Results_A, Results_B, time_grid, basis_degree, boundary_knots, internal_knots, burnin_prop, time_inhomogeneous, n_MC_samples)
}

#' Test for Unimodality for Single Stimuli Trials (Whole Trial Analysis)
#' 
#' This function conducts a bootstrap-based test for unimodality. This test is
#' used to confirm that the single stimulus trials are unimodal in the distribution
#' of spike counts.
#' 
#' @name Bootstrap_Test_Unimodality_WTA
#' @param obs_dat Vector containing number of spikes for each trial
#' @param eval_grid Vector containing points over which to evaluate the density (default is 500 points)
#' @param h_grid Vector containing a list of bandwidths for the Gaussian KDE (default is adaptively chosen)
#' @param n_boot Integer indicating the number of bootstrap samples to use (default is 10000)
#' @returns p_val Estimated p-value of test under the null hypothesis that the distribution is unimodal
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{eval_grid}}{points should cover the range of observed spike counts plus slightly more}
#'   \item{\code{h_grid}}{all bandwidths should be positive}
#'   \item{\code{n_boot}}{must be greater than 1}
#' }
#' 
#' @examples
#' ## Load sample data 
#' ## Note there is no difference between time homogeneous and time inhomogeneous processes
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## Run test for A process
#' p_val_A <- Bootsrap_Test_Unimodality_WTA(dat$n_A)
#' 
#' ## Run test for B process
#' p_val_B <- Bootsrap_Test_Unimodality_WTA(dat$n_B)
#' 
#' @export
Bootstrap_Test_Unimodality_WTA <- function(obs_dat, eval_grid = NULL, h_grid = NULL, n_boot = 10000L) {
    .Call('_NeuralComp_Bootstrap_Test_Unimodality_WTA', PACKAGE = 'NeuralComp', obs_dat, eval_grid, h_grid, n_boot)
}

Diff_LLPD <- function(X_A, X_B, n_A, n_B, Results_A, Results_B, Results_joint, basis_degree, boundary_knots, internal_knots, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_Diff_LLPD', PACKAGE = 'NeuralComp', X_A, X_B, n_A, n_B, Results_A, Results_B, Results_joint, basis_degree, boundary_knots, internal_knots, time_inhomogeneous, burnin_prop)
}

Test_IIGPP_Fit <- function(X, n, Results, basis_degree, boundary_knots, internal_knots, trial_time, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_Test_IIGPP_Fit', PACKAGE = 'NeuralComp', X, n, Results, basis_degree, boundary_knots, internal_knots, trial_time, time_inhomogeneous, burnin_prop)
}

rcpparma_hello_world <- function() {
    .Call('_NeuralComp_rcpparma_hello_world', PACKAGE = 'NeuralComp')
}

rcpparma_outerproduct <- function(x) {
    .Call('_NeuralComp_rcpparma_outerproduct', PACKAGE = 'NeuralComp', x)
}

rcpparma_innerproduct <- function(x) {
    .Call('_NeuralComp_rcpparma_innerproduct', PACKAGE = 'NeuralComp', x)
}

rcpparma_bothproducts <- function(x) {
    .Call('_NeuralComp_rcpparma_bothproducts', PACKAGE = 'NeuralComp', x)
}

dinv_gauss <- function(x, mean, shape) {
    .Call('_NeuralComp_dinv_gauss', PACKAGE = 'NeuralComp', x, mean, shape)
}

pinv_gauss <- function(x, mean, shape) {
    .Call('_NeuralComp_pinv_gauss', PACKAGE = 'NeuralComp', x, mean, shape)
}

dnorm_test <- function(prop_momentum) {
    .Call('_NeuralComp_dnorm_test', PACKAGE = 'NeuralComp', prop_momentum)
}

