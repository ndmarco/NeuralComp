# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Construct B-splines
#' 
#' Creates B-spline basis functions evaluated at the time points of interest.
#' 
#' @name GetBSpline
#' @param time Vector of time points of interest
#' @param basis_degree Integer indicating the degree of B-splines
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @returns Matrix containing the B-splines evaluated at the time points of interest
#' 
#' @examples
#' time <- seq(0, 1, 0.01)
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' B <- GetBSpline(time, basis_degree, boundary_knots, internal_knots)
#' 
#' @export
GetBSpline <- function(time, basis_degree, boundary_knots, internal_knots) {
    .Call('_NeuralComp_GetBSpline', PACKAGE = 'NeuralComp', time, basis_degree, boundary_knots, internal_knots)
}

#' Sampler for Drift-Diffusion Competition Model
#' 
#' Conducts MCMC to get posterior samples from the drift-diffusion competition model.
#' This function can fit a time-homogeneous model, as well as a time-inhomogeneous 
#' model.
#' 
#' @name Sampler_Competition
#' @param X_A List of vectors containing the ISIs of A trials
#' @param X_B List of vectors containing the ISIs of B trials
#' @param X_AB List of vectors containing the ISIs of AB trials
#' @param n_A Vector containing number of spikes for each A trial
#' @param n_B Vector containing number of spikes for each B trial
#' @param n_AB Vector containing number of spikes for each AB trial
#' @param MCMC_iters Integer containing the number of MCMC_iterations excluding warm up blocks
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param end_time Double containing the end of the experimental window (experimental window assumed [0, end_time])
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param Warm_block1 Integer containing number of iterations to adapt the leapfrog step size under identity mass matrices
#' @param Warm_block2 Integer containing number of iterations to adapt the mass matrices, leapfrog step size, and delta sampling parameters
#' @param Leapfrog_steps Integer containing number of leapfrog steps per HMC step
#' @param I_A_mean Double containing the value for the mean parameter of IG prior on I_A
#' @param I_A_shape Double containing the value for the shape parameter of IG prior on I_A
#' @param I_B_mean Double containing the value for the mean parameter of IG prior on I_B
#' @param I_B_shape Double containing the value for the shape parameter of IG prior on I_B
#' @param sigma_A_mean Double containing the value for the mean parameter of IG prior on sigma_A
#' @param sigma_A_shape Double containing the value for the shape parameter of IG prior on sigma_A
#' @param sigma_B_mean Double containing the value for the mean parameter of IG prior on sigma_B
#' @param sigma_B_shape Double containing the value for the shape parameter of IG prior on sigma_B
#' @param delta_shape Double containing the value for the shape parameter of gamma prior on delta
#' @param delta_rate Double containing the value for the rate parameter of gamma prior on delta
#' @param step_size_theta Double containing initial leapfrog step size for theta parameters
#' @param step_size_FR Double containing initial leapfrog step size for time-inhomogeneous firing rate parameters
#' @param delta_proposal_mean Double containing the value for mean parameter of the lognormal proposal distribution of delta parameter
#' @param delta_proposal_sd Double containing the value for sd parameter of the lognormal proposal distribution of delta parameter
#' @param alpha_labels Double containing probability that proposed new deltas come from the prior on delta instead of adapted lognormal distribution
#' @param nu Double containing the value for the degrees of freedom parameter of the folded-t prior distribution on I_A_sigma and I_B_sigma
#' @param gamma Double containing the value for the scale parameter of the folded-t prior distribution on I_A_sigma and I_B_sigma
#' @param delta_adaptation_block Integer containing how often the delta sampling parameters should be updated in Warm_block2
#' @param Mass_adaptation_block Integer containing how often the Mass Matrix should be updated in Warm_block2
#' @param M_proposal Integer containing the number of deltas proposed when sampling delta
#' @returns List containing:
#' \describe{
#'   \item{\code{theta}}{Matrix of samples of the theta parameters (I_A, I_B, sigma_A, sigma_B, delta) where each row is an MCMC sample}
#'   \item{\code{labels}}{List of matrices where each item in the list contains MCMC samples from an AB trial}
#'   \item{\code{basis_coef_A}}{Matrix containing MCMC samples of the coefficients of the B-splines for the A process (if time-inhomogeneous)}
#'   \item{\code{basis_coef_B}}{Matrix containing MCMC samples of the coefficients of the B-splines for the B process (if time-inhomogeneous)}
#'   \item{\code{I_A_sigma_sq}}{Vector of MCMC samples of I_A_sigma squared}
#'   \item{\code{I_B_sigma_sq}}{Vector of MCMC samples of I_B_sigma squared}
#'   \item{\code{LogLik}}{Log-likelihood for each MCMC iteration}
#'   \item{\code{LogPosterior}}{Log-Posterior for each MCMC iteration}
#'   
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{end_time}}{must be larger than 0 and all spike times must be before end_time}
#'   \item{\code{I_A_mean}}{must be greater than 0}
#'   \item{\code{I_A_shape}}{must be greater than 0}
#'   \item{\code{I_B_mean}}{must be greater than 0}
#'   \item{\code{I_B_shape}}{must be greater than 0}
#'   \item{\code{sigma_A_mean}}{must be greater than 0}
#'   \item{\code{sigma_A_shape}}{must be greater than 0}
#'   \item{\code{sigma_B_mean}}{must be greater than 0}
#'   \item{\code{sigma_B_shape}}{must be greater than 0}
#'   \item{\code{delta_shape}}{must be greater than 0}
#'   \item{\code{delta_rate}}{must be greater than 0}
#'   \item{\code{step_size_theta}}{must be greater than 0}
#'   \item{\code{step_size_FR}}{must be greater than 0}
#'   \item{\code{delta_proposal_sd}}{must be greater than 0}
#'   \item{\code{alpha_labels}}{must be between 0 and 1}
#'   \item{\code{alpha}}{must be greater than 0}
#'   \item{\code{beta}}{must be greater than 0}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' end_time <- 1
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                end_time, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                                time_inhomogeneous = FALSE)
#' 
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                end_time, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#' 
#' @export
Sampler_Competition <- function(X_A, X_B, X_AB, n_A, n_B, n_AB, MCMC_iters, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, Warm_block1 = 500L, Warm_block2 = 4000L, Leapfrog_steps = 10L, I_A_mean = 40, I_A_shape = 1, I_B_mean = 40, I_B_shape = 1, sigma_A_mean = 6.32, sigma_A_shape = 1, sigma_B_mean = 6.32, sigma_B_shape = 1, delta_shape = 0.01, delta_rate = 0.1, step_size_theta = 0.001, step_size_FR = 0.001, delta_proposal_mean = -2, delta_proposal_sd = 0.3, alpha_labels = 0.2, nu = 5, gamma = 0.25, delta_adaptation_block = 100L, Mass_adaptation_block = 500L, M_proposal = 10L) {
    .Call('_NeuralComp_Sampler_Competition', PACKAGE = 'NeuralComp', X_A, X_B, X_AB, n_A, n_B, n_AB, MCMC_iters, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, Warm_block1, Warm_block2, Leapfrog_steps, I_A_mean, I_A_shape, I_B_mean, I_B_shape, sigma_A_mean, sigma_A_shape, sigma_B_mean, sigma_B_shape, delta_shape, delta_rate, step_size_theta, step_size_FR, delta_proposal_mean, delta_proposal_sd, alpha_labels, nu, gamma, delta_adaptation_block, Mass_adaptation_block, M_proposal)
}

#' Sampler for IIGPP model
#' 
#' Conducts MCMC to get posterior samples from an (inhomogeneous) inverse Gaussian point process.
#' This function can fit a time-homogeneous model, as well as a time-inhomogeneous 
#' model.
#' 
#' @name Sampler_IIGPP
#' @param X List of vectors containing the ISIs the trials
#' @param n Vector containing number of spikes for the trials
#' @param MCMC_iters Integer containing the number of MCMC_iterations excluding warm up blocks
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param end_time Double containing the end of the experimental window (experimental window assumed [0, end_time])
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param Warm_block1 Integer containing number of iterations to adapt the leapfrog step size under identity mass matrices
#' @param Warm_block2 Integer containing number of iterations to adapt the mass matrices, leapfrog step size, and delta sampling parameters
#' @param Leapfrog_steps Integer containing number of leapfrog steps per HMC step
#' @param I_mean Double containing the value for the mean parameter of IG prior on I
#' @param I_shape Double containing the value for the shape parameter of IG prior on I
#' @param sigma_mean Double containing the value for the mean parameter of IG prior on sigma
#' @param sigma_shape Double containing the value for the shape parameter of IG prior on sigma
#' @param step_size_theta Double containing initial leapfrog step size for theta parameters
#' @param step_size_FR Double containing initial leapfrog step size for time-inhomogeneous firing rate parameters
#' @param nu Double containing the value for the degrees of freedom parameter of the folded-t prior distribution on I_A_sigma and I_B_sigma
#' @param gamma Double containing the value for the scale parameter of the folded-t prior distribution on I_A_sigma and I_B_sigma
#' @param Mass_adaptation_block Integer containing how often the Mass Matrix should be updated in Warm_block2
#' @param M_proposal Integer containing the number of deltas proposed when sampling delta
#' @returns List containing:
#' \describe{
#'   \item{\code{theta}}{Matrix of samples of the theta parameters (I, sigma) where each row is an MCMC sample}
#'   \item{\code{basis_coef}}{Matrix containing MCMC samples of the coefficients of the B-splines for the inhomogeneous process (if time-inhomogeneous)}
#'   \item{\code{I_sigma_sq}}{Vector of MCMC samples of I_sigma squared}
#'   \item{\code{LogLik}}{Log-likelihood for each MCMC iteration}
#'   \item{\code{LogPosterior}}{Log-Posterior for each MCMC iteration}
#'   
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{end_time}}{must be larger than 0 and all spike times must be before end_time}
#'   \item{\code{I_mean}}{must be greater than 0}
#'   \item{\code{I_shape}}{must be greater than 0}
#'   \item{\code{sigma_mean}}{must be greater than 0}
#'   \item{\code{sigma_shape}}{must be greater than 0}
#'   \item{\code{step_size_theta}}{must be greater than 0}
#'   \item{\code{step_size_FR}}{must be greater than 0}
#'   \item{\code{delta_proposal_sd}}{must be greater than 0}
#'   \item{\code{alpha}}{must be greater than 0}
#'   \item{\code{beta}}{must be greater than 0}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                          internal_knots, end_time, Warm_block1 = Warm_block1, 
#'                          Warm_block2 = Warm_block2, time_inhomogeneous = FALSE)
#' 
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots, 
#'                          internal_knots, end_time, Warm_block1 = Warm_block1,
#'                          Warm_block2 = Warm_block2)
#' 
#' @export
Sampler_IIGPP <- function(X, n, MCMC_iters, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, Warm_block1 = 500L, Warm_block2 = 2000L, Leapfrog_steps = 10L, I_mean = 40, I_shape = 1, sigma_mean = 6.32, sigma_shape = 1, step_size_theta = 0.001, step_size_FR = 0.001, nu = 5, gamma = 0.25, Mass_adaptation_block = 500L, M_proposal = 10L) {
    .Call('_NeuralComp_Sampler_IIGPP', PACKAGE = 'NeuralComp', X, n, MCMC_iters, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, Warm_block1, Warm_block2, Leapfrog_steps, I_mean, I_shape, sigma_mean, sigma_shape, step_size_theta, step_size_FR, nu, gamma, Mass_adaptation_block, M_proposal)
}

#' Constructs CI for IIGPP Firing Rate
#' 
#' Constructs credible intervals for the time-inhomgeneous input current function (I) of the inhomogeneous
#' inverse Gaussian point process (IIGPP) model.
#' 
#' @name FR_CI_IIGPP
#' @param time Vector of time points at which pointwise credible intervals will be constructed
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param Results List produced from running \code{Sampler_IIGPP}
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in
#' @param alpha Double indicating the size of the credible interval ((1 - alpha) * 100 percent)
#' 
#' @returns List containing:
#' \describe{
#'   \item{\code{FR_MCMC_Samps}}{Matrix of MCMC samples of the input current function at the specified time points}
#'   \item{\code{FR_CI}}{Matrix containing the upper and lower values of the credible interval at the specified time points (first column is lower value, second column is upper value)}
#'   \item{\code{FR_Median}}{Vector containing the estimated posterior median at the specified time points}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{alpha}}{must be between 0 and 0.5}
#' }
#' 
#' @examples
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots, 
#'                          internal_knots, end_time, Warm_block1 = Warm_block1,
#'                          Warm_block2 = Warm_block2)
#' 
#' ## Get CI
#' time <- seq(0, 1, 0.01)
#' CI <- FR_CI_IIGPP(time, basis_degree, boundary_knots, internal_knots, results)
#' 
#' ## plot CI
#' CI_range <- c(min(CI$FR_CI)-5, max(CI$FR_CI) + 5)
#' plot(time, CI$FR_median, type = 'l', col = "red", ylim = CI_range)
#' lines(time, CI$FR_CI[,1], col = "blue")
#' lines(time, CI$FR_CI[,2], col = "blue")
#' 
#' @export
FR_CI_IIGPP <- function(time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop = 0.3, alpha = 0.05) {
    .Call('_NeuralComp_FR_CI_IIGPP', PACKAGE = 'NeuralComp', time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop, alpha)
}

#' Constructs CI for Competition Firing Rate
#' 
#' Constructs credible intervals for the time-inhomgeneous input current (I) of the 
#' competition model for time-inhomogeneous models.
#' 
#' @name FR_CI_Competition
#' @param time Vector of time points at which pointwise credible intervals will be constructed
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param Results List produced from running \code{Sampler_Competition}
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in
#' @param alpha Double indicating the size of the credible interval ((1 - alpha) * 100 percent)
#' 
#' @returns List containing:
#' \describe{
#'   \item{\code{A_FR_MCMC_Samps}}{Matrix of MCMC samples of the A input current function at the specified time points}
#'   \item{\code{B_FR_MCMC_Samps}}{Matrix of MCMC samples of the B input current function at the specified time points}
#'   \item{\code{A_FR_CI}}{Matrix containing the upper and lower values of the A input current function credible interval at the specified time points (first column is lower value, second column is upper value)}
#'   \item{\code{B_FR_CI}}{Matrix containing the upper and lower values of the B input current function credible interval at the specified time points (first column is lower value, second column is upper value)}
#'   \item{\code{A_FR_Median}}{Vector containing the estimated posterior median A input current function at the specified time points}
#'   \item{\code{B_FR_Median}}{Vector containing the estimated posterior median B input current function at the specified time points}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{alpha}}{must be between 0 and 0.5}
#' }
#' 
#' @examples
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                end_time, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#' 
#' ## Get CI
#' time <- seq(0, 1, 0.01)
#' CI <- FR_CI_Competition(time, basis_degree, boundary_knots, internal_knots, results)
#' 
#' ## plot A input current CI
#' CI_range <- c(min(CI$A_FR_CI)-5, max(CI$A_FR_CI) + 5)
#' plot(time, CI$A_FR_median, type = 'l', col = "red", ylim = CI_range)
#' lines(time, CI$A_FR_CI[,1], col = "blue")
#' lines(time, CI$A_FR_CI[,2], col = "blue")
#' 
#' ## plot B input current CI
#' CI_range <- c(min(CI$B_FR_CI)-5, max(CI$B_FR_CI) + 5)
#' plot(time, CI$B_FR_median, type = 'l', col = "red", ylim = CI_range)
#' lines(time, CI$B_FR_CI[,1], col = "blue")
#' lines(time, CI$B_FR_CI[,2], col = "blue")
#' 
#' @export
FR_CI_Competition <- function(time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop = 0.3, alpha = 0.05) {
    .Call('_NeuralComp_FR_CI_Competition', PACKAGE = 'NeuralComp', time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop, alpha)
}

#' Calculates WAIC for the Competition Model
#' 
#' This function calculates the Watanabe-Akaike information criterion (WAIC) for 
#' the drift-diffusion competition model using the marginal likelihood (marginalizing out the labels).
#' This function will use the output from 
#' \code{Sampler_Competition}. The WAIC is defined on the deviance scale as waic = -2(lppd - p),
#' where lppd is the log pointwise predictive density, and p is the effective number of parameters.
#' The Marginal WAIC is akin to leave-one-spike-train-out cross validation (asymptotically).
#' 
#' @name WAIC_Competition
#' @param X_A List of vectors containing the ISIs of A trials
#' @param X_B List of vectors containing the ISIs of B trials
#' @param X_AB List of vectors containing the ISIs of AB trials
#' @param n_A Vector containing number of spikes for each A trial
#' @param n_B Vector containing number of spikes for each B trial
#' @param n_AB Vector containing number of spikes for each AB trial
#' @param Results List produced from running \code{Sampler_Competition}
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param end_time Double containing the end of the experimental window (experimental window assumed [0, end_time])
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @returns List containing:
#' \describe{
#'   \item{\code{WAIC}}{Estimate of WAIC}
#'   \item{\code{LPPD}}{Estimate of LPPD}
#'   \item{\code{Effective_pars}}{Estimated Effective number of parameters}
#'   \item{\code{llik_A}}{Log-likelihood for A trial spike trains}
#'   \item{\code{llik_B}}{Log-likelihood for B trial spike trains}
#'   \item{\code{llik_AB}}{Marginal log-likelihood for AB trial spike trains}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{end_time}}{must be larger than 0 and all spike times must be before end_time}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                end_time, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                                time_inhomogeneous = FALSE)
#'                                
#' ## Calculate WAIC
#' WAIC <- WAIC_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB,
#'                          results, basis_degree, boundary_knots, internal_knots, end_time,
#'                          time_inhomogeneous = FALSE)
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                end_time, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#' 
#' ## Calculate WAIC
#' WAIC <- WAIC_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB,
#'                          results, basis_degree, boundary_knots, internal_knots,
#'                          end_time)
#' 
#' @export
WAIC_Competition <- function(X_A, X_B, X_AB, n_A, n_B, n_AB, Results, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_WAIC_Competition', PACKAGE = 'NeuralComp', X_A, X_B, X_AB, n_A, n_B, n_AB, Results, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, burnin_prop)
}

#' Calculates WAIC for the IIGPP Model
#' 
#' This function calculates the Watanabe-Akaike information criterion (WAIC) for 
#' the (inhomogeneous) inverse Gaussian point process (IIGPP) model. This function will use the output from
#' \code{Sampler_IIGPP} fit for the A, B, and AB data. The WAIC is defined on the 
#' deviance scale as waic = -2(lppd - p), where lppd is the log pointwise 
#' predictive density, and p is the effective number of parameters.
#' 
#' @name WAIC_IIGPP
#' @param X_A List of vectors containing the ISIs of A trials
#' @param X_B List of vectors containing the ISIs of B trials
#' @param X_AB List of vectors containing the ISIs of AB trials
#' @param n_A Vector containing number of spikes for each A trial
#' @param n_B Vector containing number of spikes for each B trial
#' @param n_AB Vector containing number of spikes for each AB trial
#' @param Results_A List produced from running \code{Sampler_IIGPP} for A trials
#' @param Results_B List produced from running \code{Sampler_IIGPP} for B trials
#' @param Results_AB List produced from running \code{Sampler_IIGPP} for AB trials
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-spline
#' @param end_time Double containing the end of the experimental window (experimental window assumed [0, end_time])
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @returns List containing:
#' \describe{
#'   \item{\code{WAIC}}{Estimate of WAIC}
#'   \item{\code{LPPD}}{Estimate of LPPD}
#'   \item{\code{Effective_pars}}{Estimated Effective number of parameters}
#'   \item{\code{llik_A}}{Log-likelihood for A trial spike trains}
#'   \item{\code{llik_B}}{Log-likelihood for B trial spike trains}
#'   \item{\code{llik_AB}}{Log-likelihood for AB trial spike trains}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{end_time}}{must be larger than 0 and all spike times must be before end_time}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain for A trials
#' results_A <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                            internal_knots, end_time, Warm_block1 = Warm_block1,
#'                            Warm_block2 = Warm_block2, time_inhomogeneous = FALSE)
#'                        
#' ## Run MCMC chain for B trials
#' results_B<- Sampler_IIGPP(dat$X_B, dat$n_B, MCMC_iters, basis_degree, boundary_knots,
#'                           internal_knots, end_time, Warm_block1 = Warm_block1, 
#'                           Warm_block2 = Warm_block2, time_inhomogeneous = FALSE)
#'
#' ## Run MCMC chain for AB trials
#' results_AB <- Sampler_IIGPP(dat$X_AB, dat$n_AB, MCMC_iters, basis_degree, boundary_knots,
#'                             internal_knots, end_time, Warm_block1 = Warm_block1, 
#'                             Warm_block2 = Warm_block2, time_inhomogeneous = FALSE)         
#' ## Calculate WAIC
#' WAIC <- WAIC_IIGPP(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, results_A,
#'                    results_B, results_AB, basis_degree, boundary_knots, internal_knots,
#'                    end_time, time_inhomogeneous = FALSE)
#' 
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain for A trials
#' results_A <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                            internal_knots, end_time, Warm_block1 = Warm_block1, 
#'                            Warm_block2 = Warm_block2)
#'                        
#' ## Run MCMC chain for B trials
#' results_B<- Sampler_IIGPP(dat$X_B, dat$n_B, MCMC_iters, basis_degree, boundary_knots,
#'                           internal_knots, end_time, Warm_block1 = Warm_block1, 
#'                           Warm_block2 = Warm_block2)
#'
#' ## Run MCMC chain for AB trials
#' results_AB <- Sampler_IIGPP(dat$X_AB, dat$n_AB, MCMC_iters, basis_degree, boundary_knots,
#'                             internal_knots, end_time, Warm_block1 = Warm_block1, 
#'                             Warm_block2 = Warm_block2)
#'
#' WAIC <- WAIC_IIGPP(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, results_A,
#'                    results_B, results_AB, basis_degree, boundary_knots, internal_knots,
#'                    end_time)
#' 
#' @export
WAIC_IIGPP <- function(X_A, X_B, X_AB, n_A, n_B, n_AB, Results_A, Results_B, Results_AB, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_WAIC_IIGPP', PACKAGE = 'NeuralComp', X_A, X_B, X_AB, n_A, n_B, n_AB, Results_A, Results_B, Results_AB, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, burnin_prop)
}

#' Calculates WAIC for the Winner-take-all Model
#' 
#' This function calculates the Watanabe-Akaike information criterion (WAIC) for 
#' the winner-take-all model, which can be constructed via IIGPP models. This 
#' function will use the output from \code{Sampler_IIGPP} fit for the A, B, and 
#' AB data. The WAIC is defined on the deviance scale as waic = -2(lppd - p), 
#' where lppd is the log pointwise predictive density, and p is the effective 
#' number of parameters.
#' 
#' @name WAIC_Winner_Take_All
#' @param X_A List of vectors containing the ISIs of A trials (and AB trials if testing winner-take-all (A stimulus))
#' @param X_B List of vectors containing the ISIs of B trials (and AB trials if testing winner-take-all (B stimulus))
#' @param n_A Vector containing number of spikes for each A trial (and AB trial if testing winner-take-all (A stimulus))
#' @param n_B Vector containing number of spikes for each B trial (and AB trial if testing winner-take-all (B stimulus))
#' @param Results_A List produced from running \code{Sampler_IIGPP} for A trials (and AB trials if testing winner-take-all (A stimulus))
#' @param Results_B List produced from running \code{Sampler_IIGPP} for B trials (and AB trials if testing winner-take-all (B stimulus))
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param end_time Double containing the end of the experimental window (experimental window assumed [0, end_time])
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @returns List containing:
#' \describe{
#'   \item{\code{WAIC}}{Estimate of WAIC}
#'   \item{\code{LPPD}}{Estimate of LPPD}
#'   \item{\code{Effective_pars}}{Estimated Effective number of parameters}
#'   \item{\code{llik_A}}{Log-likelihood for A trial spike trains (and AB trials if testing winner-take-all (A stimulus))}
#'   \item{\code{llik_B}}{Log-likelihood for B trial spike trains (and AB trials if testing winner-take-all (B stimulus))}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{end_time}}{must be larger than 0 and all spike times must be before end_time}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ################################################
#' ## Test Winner-take-all (Encoding Stimulus A) ##
#' ################################################
#' 
#' ### Create new dataset of A and AB trials together
#' dat_A_AB <- c(dat$X_A, dat$X_AB)
#' n_A_AB <- c(dat$n_A, dat$n_AB)
#' 
#' ## Run MCMC chain for A trials and AB trials
#' results_A_AB <- Sampler_IIGPP(dat_A_AB, n_A_AB, MCMC_iters, basis_degree, boundary_knots,
#'                               internal_knots, end_time, Warm_block1 = Warm_block1,
#'                               Warm_block2 = Warm_block2, time_inhomogeneous = FALSE)
#'                        
#' ## Run MCMC chain for B trials
#' results_B <- Sampler_IIGPP(dat$X_B, dat$n_B, MCMC_iters, basis_degree, boundary_knots,
#'                            internal_knots, end_time, Warm_block1 = Warm_block1, 
#'                            Warm_block2 = Warm_block2, time_inhomogeneous = FALSE)
#'
#' ## Calculate WAIC - Encoding stimulus A
#' WAIC <- WAIC_Winner_Take_All(dat_A_AB, dat$X_B, n_A_AB, dat$n_B, results_A_AB,
#'                              results_B, basis_degree, boundary_knots,
#'                              internal_knots, end_time, time_inhomogeneous = FALSE)
#' 
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ################################################
#' ## Test Winner-take-all (Encoding Stimulus B) ##
#' ################################################
#' 
#' ### Create new dataset of A and AB trials together
#' dat_B_AB <- c(dat$X_B, dat$X_AB)
#' n_B_AB <- c(dat$n_B, dat$n_AB)
#' 
#' ## Run MCMC chain for A trials 
#' results_A <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                            internal_knots, end_time, Warm_block1 = Warm_block1,
#'                            Warm_block2 = Warm_block2)
#'                        
#' ## Run MCMC chain for B trials and AB trials
#' results_B_AB <- Sampler_IIGPP(dat_B_AB, n_B_AB, MCMC_iters, basis_degree, boundary_knots,
#'                               internal_knots, end_time, Warm_block1 = Warm_block1, 
#'                               Warm_block2 = Warm_block2)
#'
#' ## Calculate WAIC - Encoding stimulus B
#' WAIC <- WAIC_Winner_Take_All(dat$X_A, dat_B_AB, dat$n_A, n_B_AB, results_A,
#'                              results_B_AB, basis_degree, boundary_knots,
#'                              internal_knots, end_time)
#' 
#' @export
WAIC_Winner_Take_All <- function(X_A, X_B, n_A, n_B, Results_A, Results_B, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_WAIC_Winner_Take_All', PACKAGE = 'NeuralComp', X_A, X_B, n_A, n_B, Results_A, Results_B, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, burnin_prop)
}

#' Posterior Predictive Sampling for Competition Model
#' 
#' This function generates posterior predictive samples of scientific interest from
#' the competition model. Specifically, this function allows you to obtain (1) posterior
#' predictive samples from the A condition, B condition, and AB conditions (2) posterior
#' predictive samples of spike counts under the A condition, B condition, and AB conditions, 
#' (3) posterior predictive samples of time spent encoding each state (4) posterior predictive 
#' samples for the number of switches in a trial. This function is to be used after running
#' \code{Sampler_Competition}.
#' 
#' @name Competition_Posterior_Predictive
#' @param end_time Double containing length of trial to simulate
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param Results List produced from running \code{Sampler_Competition}
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param n_samples Integer containing number of posterior predictive samples to generate
#' @returns List containing:
#' \describe{
#'   \item{\code{posterior_pred_samples_A}}{Posterior predictive samples of spike trains under the A stimulus}
#'   \item{\code{posterior_pred_samples_B}}{Posterior predictive samples of spike trains under the B stimulus}
#'   \item{\code{posterior_pred_samples_AB}}{Posterior predictive samples of spike trains under the A  and B stimuli}
#'   \item{\code{posterior_pred_labels}}{labels corresponding to posterior_pred_samples_AB}
#'   \item{\code{n_A}}{Number of spikes in each of the spike trains in posterior_pred_samples_A}
#'   \item{\code{n_B}}{Number of spikes in each of the spike trains in posterior_pred_samples_B}
#'   \item{\code{n_AB}}{Number of spikes in each of the spike trains in posterior_pred_samples_AB}
#'   \item{\code{switch_times}}{Times spent in each encoding state in the spike trains generated in posterior_pred_samples_AB}
#'   \item{\code{switch_states}}{Encoding state (labels) corresponding to switch_times}
#'   \item{\code{n_switches}}{number of switches observed in each spike train generated in posterior_pred_samples_AB}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{n_sample}}{must be greater than 1}
#'   \item{\code{end_time}}{must be larger than 0 and all spike times must be before end_time}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                end_time, Warm_block1 = Warm_block1, 
#'                                Warm_block2 = Warm_block2, time_inhomogeneous = FALSE)
#'                                
#' ## Posterior Predictive Samples
#' post_pred <- Competition_Posterior_Predictive(end_time, basis_degree, boundary_knots, 
#'                                               internal_knots, results, 
#'                                               time_inhomogeneous = FALSE)
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                end_time, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#'                                
#' ## Posterior Predictive Samples                               
#' post_pred <- Competition_Posterior_Predictive(end_time, basis_degree, boundary_knots,
#'                                               internal_knots, results)
#'                                               
#' @export
Competition_Posterior_Predictive <- function(end_time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop = 0.2, time_inhomogeneous = TRUE, n_samples = 10000L) {
    .Call('_NeuralComp_Competition_Posterior_Predictive', PACKAGE = 'NeuralComp', end_time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop, time_inhomogeneous, n_samples)
}

#' Calculate Difference in LPPD to Ensure that the A and B Stimuli are Sufficiently Different
#' 
#' This function calculates the difference in LPPD between separate models for 
#' the A and B spike trains and a joint model for the A and B spike trains. The
#' key idea is that the separate models should be able to model the spike trains
#' significantly better than the joint model, indicating the two spike train 
#' distributions are significantly different between the A and B stimuli. The 
#' function will use the output from \code{Sampler_IIGPP} fit for the A, B, and 
#' joint data (A and B single-stimulus spike trains). 
#' 
#' @name Diff_LPPD
#' @param X_A List of vectors containing the ISIs of A trials
#' @param X_B List of vectors containing the ISIs of B trials
#' @param n_A Vector containing number of spikes for each A trial
#' @param n_B Vector containing number of spikes for each B trial
#' @param Results_A List produced from running \code{Sampler_IIGPP} for A trials
#' @param Results_B List produced from running \code{Sampler_IIGPP} for B trials
#' @param Results_joint List produced from running \code{Sampler_IIGPP} for the A and B trials combined
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param end_time Double containing the end of the experimental window (experimental window assumed [0, end_time])
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @returns Double containing the difference in LPPD between the separate models and the joint model
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{end_time}}{must be larger than 0 and all spike times must be before end_time}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ### Fit Separate Models
#' 
#' ## Run MCMC chain for A trials
#' results_A <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                            internal_knots, end_time, Warm_block1 = Warm_block1,
#'                            Warm_block2 = Warm_block2, time_inhomogeneous = FALSE)
#'                        
#' ## Run MCMC chain for B trials
#' results_B<- Sampler_IIGPP(dat$X_B, dat$n_B, MCMC_iters, basis_degree, boundary_knots,
#'                           internal_knots, end_time, Warm_block1 = Warm_block1, 
#'                           Warm_block2 = Warm_block2, time_inhomogeneous = FALSE)
#' 
#' ### Fit Joint Model
#' 
#' ### Create new dataset of A and B trials together
#' dat_A_B <- c(dat$X_A, dat$X_B)
#' n_A_B <- c(dat$n_A, dat$n_B)
#' 
#' ## Run MCMC chain for A trials and B trials jointly
#' results_A_B <- Sampler_IIGPP(dat_A_B, n_A_B, MCMC_iters, basis_degree, boundary_knots,
#'                              internal_knots, end_time, Warm_block1 = Warm_block1,
#'                              Warm_block2 = Warm_block2, time_inhomogeneous = FALSE)
#'                       
#'
#' ## Calculate Difference in LPPD
#' diff <- Diff_LPPD(dat$X_A, dat$X_B, dat$n_A, dat$n_B, results_A,
#'                   results_B, results_A_B, basis_degree, boundary_knots,
#'                   internal_knots, end_time, time_inhomogeneous = FALSE)
#' 
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ### Fit Separate Models
#' 
#' ## Run MCMC chain for A trials
#' results_A <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                            internal_knots, end_time, Warm_block1 = Warm_block1,
#'                            Warm_block2 = Warm_block2)
#'                        
#' ## Run MCMC chain for B trials
#' results_B<- Sampler_IIGPP(dat$X_B, dat$n_B, MCMC_iters, basis_degree, boundary_knots,
#'                           internal_knots, end_time, Warm_block1 = Warm_block1, 
#'                           Warm_block2 = Warm_block2)
#' 
#' ### Fit Joint Model
#' 
#' ### Create new dataset of A and B trials together
#' dat_A_B <- c(dat$X_A, dat$X_B)
#' n_A_B <- c(dat$n_A, dat$n_B)
#' 
#' ## Run MCMC chain for A trials and B trials jointly
#' results_A_B <- Sampler_IIGPP(dat_A_B, n_A_B, MCMC_iters, basis_degree, boundary_knots,
#'                              internal_knots, end_time, Warm_block1 = Warm_block1,
#'                              Warm_block2 = Warm_block2)
#'                       
#'
#' ## Calculate Difference in LPPD
#' diff <- Diff_LPPD(dat$X_A, dat$X_B, dat$n_A, dat$n_B, results_A,
#'                   results_B, results_A_B, basis_degree, boundary_knots,
#'                   internal_knots, end_time)
#' 
#' @export
Diff_LPPD <- function(X_A, X_B, n_A, n_B, Results_A, Results_B, Results_joint, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_Diff_LPPD', PACKAGE = 'NeuralComp', X_A, X_B, n_A, n_B, Results_A, Results_B, Results_joint, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, burnin_prop)
}

#' Calculates Posterior P-values for IIGPP Models
#' 
#' This function calculates the posterior p-value using different discrepency variables.
#' Specifically, this function uses the the following discrepency variables: (1) Average 
#' Log-Likelihood, (2) Mean of the Spike Counts, and (3) Variance of the Spike Counts. Using these
#' three discrepancy variables, this function calculates posterior p-values which
#' calculate the discrepency between the fitted model and the observed spike trains.
#' 
#' @name Test_IIGPP_Fit
#' @param X List of vectors containing the ISIs of one of the two (A or B) single stimulus trials
#' @param n Vector containing number of spikes for each one spike train corresponding to X
#' @param Results List produced from running \code{Sampler_IIGPP} for one of the two (A or B) single stimulus trials
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param end_time Double containing the end of the experimental window (experimental window assumed [0, end_time])
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @returns List containing:
#' \describe{
#'   \item{\code{p_val}}{Posterior predictive p-value using average log-likelihood as the discrepency variable}
#'   \item{\code{p_val_mean_SC}}{Posterior predictive p-value using the mean of the spike counts as the discrepency variable}
#'   \item{\code{p_val_var_SC}}{Posterior predictive p-value using the variance of the spike counts as the discrepency variable}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{end_time}}{must be larger than 0 and all spike times must be before end_time}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots, 
#'                          internal_knots, end_time, Warm_block1 = Warm_block1,
#'                          Warm_block2 = Warm_block2, time_inhomogeneous = FALSE)
#'
#' posterior_p_val <- Test_IIGPP_Fit(dat$X_A, dat$n_A, results, basis_degree,
#'                                   boundary_knots, internal_knots, end_time,
#'                                   time_inhomogeneous = FALSE)
#' 
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS",
#'                package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots, 
#'                          internal_knots, end_time, Warm_block1 = Warm_block1,
#'                          Warm_block2 = Warm_block2)
#'
#' posterior_p_val <- Test_IIGPP_Fit(dat$X_A, dat$n_A, results, basis_degree,
#'                                   boundary_knots, internal_knots, end_time)
#' 
#' @export
Test_IIGPP_Fit <- function(X, n, Results, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_Test_IIGPP_Fit', PACKAGE = 'NeuralComp', X, n, Results, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, burnin_prop)
}

