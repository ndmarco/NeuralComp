# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Construct B-splines
#' 
#' Creates B-spline basis functions evaluated at the time points of interest.
#' 
#' @name GetBSpline
#' @param time Vector of time points of interest
#' @param basis_degree Integer indicating the degree of B-splines
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @returns Matrix containing the B-splines evaluated at the time points of interest
#' 
#' @examples
#' time <- seq(0, 1, 0.01)
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' B <- GetBSpline(time, basis_degree, boundary_knots, internal_knots)
#' 
#' @export
GetBSpline <- function(time, basis_degree, boundary_knots, internal_knots) {
    .Call('_NeuralComp_GetBSpline', PACKAGE = 'NeuralComp', time, basis_degree, boundary_knots, internal_knots)
}

#' Sampler for Drift-Diffusion Competition Model
#' 
#' Conducts MCMC to get posterior samples from the drift-diffusion competition model.
#' This function can fit a time-homogeneous model, as well as a time-inhomogeneous 
#' model.
#' 
#' @name Sampler_Competition
#' @param X_A List of vectors containing the ISIs of A trials
#' @param X_B List of vectors containing the ISIs of B trials
#' @param X_AB List of vectors containing the ISIs of AB trials
#' @param n_A Vector containing number of spikes for each A trial
#' @param n_B Vector containing number of spikes for each B trial
#' @param n_AB Vector containing number of spikes for each AB trial
#' @param MCMC_iters Integer containing the number of MCMC_iterations excluding warm up blocks
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param end_time Double containing the end of the experimental window (experimental window assumed [0, end_time])
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param Warm_block1 Integer containing number of iterations to adapt the leapfrog step size under identity mass matrices
#' @param Warm_block2 Integer containing number of iterations to adapt the mass matrices, leapfrog step size, and delta sampling parameters
#' @param Leapfrog_steps Integer containing number of leapfrog steps per HMC step
#' @param I_A_mean Double containing the value for the mean parameter of IG prior on I_A
#' @param I_A_shape Double containing the value for the shape parameter of IG prior on I_A
#' @param I_B_mean Double containing the value for the mean parameter of IG prior on I_B
#' @param I_B_shape Double containing the value for the shape parameter of IG prior on I_B
#' @param sigma_A_mean Double containing the value for the mean parameter of IG prior on sigma_A
#' @param sigma_A_shape Double containing the value for the shape parameter of IG prior on sigma_A
#' @param sigma_B_mean Double containing the value for the mean parameter of IG prior on sigma_B
#' @param sigma_B_shape Double containing the value for the shape parameter of IG prior on sigma_B
#' @param delta_shape Double containing the value for the shape parameter of gamma prior on delta
#' @param delta_rate Double containing the value for the rate parameter of gamma prior on delta
#' @param step_size_theta Double containing initial leapfrog step size for theta parameters
#' @param step_size_FR Double containing initial leapfrog step size for time-inhomogeneous firing rate parameters
#' @param delta_proposal_mean Double containing the value for mean parameter of the lognormal proposal distribution of delta parameter
#' @param delta_proposal_sd Double containing the value for sd parameter of the lognormal proposal distribution of delta parameter
#' @param alpha_labels Double containing probability that proposed new deltas come from the prior on delta instead of adapted lognormal distribution
#' @param nu Double containing the value for the degrees of freedom parameter of the folded-t prior distribution on I_A_sigma and I_B_sigma
#' @param gamma Double containing the value for the scale parameter of the folded-t prior distribution on I_A_sigma and I_B_sigma
#' @param delta_adaptation_block Integer containing how often the delta sampling parameters should be updated in Warm_block2
#' @param Mass_adaptation_block Integer containing how often the Mass Matrix should be updated in Warm_block2
#' @param M_proposal Integer containing the number of deltas proposed when sampling delta
#' @returns List containing:
#' \describe{
#'   \item{\code{theta}}{Matrix of samples of the theta parameters (I_A, I_B, sigma_A, sigma_B, delta) where each row is an MCMC sample}
#'   \item{\code{labels}}{List of matrices where each item in the list contains MCMC samples from an AB trial}
#'   \item{\code{basis_coef_A}}{Matrix containing MCMC samples of the coefficients of the B-splines for the A process (if time-inhomogeneous)}
#'   \item{\code{basis_coef_B}}{Matrix containing MCMC samples of the coefficients of the B-splines for the B process (if time-inhomogeneous)}
#'   \item{\code{I_A_sigma_sq}}{Vector of MCMC samples of I_A_sigma squared}
#'   \item{\code{I_B_sigma_sq}}{Vector of MCMC samples of I_B_sigma squared}
#'   \item{\code{LogLik}}{Log-likelihood for each MCMC iteration}
#'   \item{\code{LogPosterior}}{Log-Posterior for each MCMC iteration}
#'   
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{end_time}}{must be larger than 0}
#'   \item{\code{I_A_mean}}{must be greater than 0}
#'   \item{\code{I_A_shape}}{must be greater than 0}
#'   \item{\code{I_B_mean}}{must be greater than 0}
#'   \item{\code{I_B_shape}}{must be greater than 0}
#'   \item{\code{sigma_A_mean}}{must be greater than 0}
#'   \item{\code{sigma_A_shape}}{must be greater than 0}
#'   \item{\code{sigma_B_mean}}{must be greater than 0}
#'   \item{\code{sigma_B_shape}}{must be greater than 0}
#'   \item{\code{delta_shape}}{must be greater than 0}
#'   \item{\code{delta_rate}}{must be greater than 0}
#'   \item{\code{step_size_theta}}{must be greater than 0}
#'   \item{\code{step_size_FR}}{must be greater than 0}
#'   \item{\code{delta_proposal_sd}}{must be greater than 0}
#'   \item{\code{alpha_labels}}{must be between 0 and 1}
#'   \item{\code{alpha}}{must be greater than 0}
#'   \item{\code{beta}}{must be greater than 0}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' end_time <- 1
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                end_time, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                                time_inhomogeneous = FALSE)
#' 
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                end_time, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#' 
#' @export
Sampler_Competition <- function(X_A, X_B, X_AB, n_A, n_B, n_AB, MCMC_iters, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, Warm_block1 = 500L, Warm_block2 = 4000L, Leapfrog_steps = 10L, I_A_mean = 40, I_A_shape = 1, I_B_mean = 40, I_B_shape = 1, sigma_A_mean = 6.32, sigma_A_shape = 1, sigma_B_mean = 6.32, sigma_B_shape = 1, delta_shape = 0.01, delta_rate = 0.1, step_size_theta = 0.001, step_size_FR = 0.001, delta_proposal_mean = -2, delta_proposal_sd = 0.3, alpha_labels = 0.2, nu = 5, gamma = 0.25, delta_adaption_block = 100L, Mass_adaption_block = 500L, M_proposal = 10L) {
    .Call('_NeuralComp_Sampler_Competition', PACKAGE = 'NeuralComp', X_A, X_B, X_AB, n_A, n_B, n_AB, MCMC_iters, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, Warm_block1, Warm_block2, Leapfrog_steps, I_A_mean, I_A_shape, I_B_mean, I_B_shape, sigma_A_mean, sigma_A_shape, sigma_B_mean, sigma_B_shape, delta_shape, delta_rate, step_size_theta, step_size_FR, delta_proposal_mean, delta_proposal_sd, alpha_labels, nu, gamma, delta_adaption_block, Mass_adaption_block, M_proposal)
}

#' Sampler for IIGPP model
#' 
#' Conducts MCMC to get posterior samples from an (inhomogeneous) inverse Gaussian point process.
#' This function can fit a time-homogeneous model, as well as a time-inhomogeneous 
#' model.
#' 
#' @name Sampler_IIGPP
#' @param X List of vectors containing the ISIs the trials
#' @param n Vector containing number of spikes for the trials
#' @param MCMC_iters Integer containing the number of MCMC_iterations excluding warm up blocks
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param end_time Double containing the end of the experimental window (experimental window assumed [0, end_time])
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param Warm_block1 Integer containing number of iterations to adapt the leapfrog step size under identity mass matrices
#' @param Warm_block2 Integer containing number of iterations to adapt the mass matrices, leapfrog step size, and delta sampling parameters
#' @param Leapfrog_steps Integer containing number of leapfrog steps per HMC step
#' @param I_mean Double containing the value for the mean parameter of IG prior on I
#' @param I_shape Double containing the value for the shape parameter of IG prior on I
#' @param sigma_mean Double containing the value for the mean parameter of IG prior on sigma
#' @param sigma_shape Double containing the value for the shape parameter of IG prior on sigma
#' @param step_size_theta Double containing initial leapfrog step size for theta parameters
#' @param step_size_FR Double containing initial leapfrog step size for time-inhomogeneous firing rate parameters
#' @param nu Double containing the value for the degrees of freedom parameter of the folded-t prior distribution on I_A_sigma and I_B_sigma
#' @param gamma Double containing the value for the scale parameter of the folded-t prior distribution on I_A_sigma and I_B_sigma
#' @param Mass_adaptation_block Integer containing how often the Mass Matrix should be updated in Warm_block2
#' @param M_proposal Integer containing the number of deltas proposed when sampling delta
#' @returns List containing:
#' \describe{
#'   \item{\code{theta}}{Matrix of samples of the theta parameters (I, sigma) where each row is an MCMC sample}
#'   \item{\code{basis_coef}}{Matrix containing MCMC samples of the coefficients of the B-splines for the inhomogeneous process (if time-inhomogeneous)}
#'   \item{\code{I_sigma_sq}}{Vector of MCMC samples of I_sigma squared}
#'   \item{\code{LogLik}}{Log-likelihood for each MCMC iteration}
#'   \item{\code{LogPosterior}}{Log-Posterior for each MCMC iteration}
#'   
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{end_time}}{must be larger than 0}
#'   \item{\code{I_mean}}{must be greater than 0}
#'   \item{\code{I_shape}}{must be greater than 0}
#'   \item{\code{sigma_mean}}{must be greater than 0}
#'   \item{\code{sigma_shape}}{must be greater than 0}
#'   \item{\code{step_size_theta}}{must be greater than 0}
#'   \item{\code{step_size_FR}}{must be greater than 0}
#'   \item{\code{delta_proposal_sd}}{must be greater than 0}
#'   \item{\code{alpha}}{must be greater than 0}
#'   \item{\code{beta}}{must be greater than 0}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                          internal_knots, end_time, Warm_block1 = Warm_block1, 
#'                          Warm_block2 = Warm_block2, time_inhomogeneous = FALSE)
#' 
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots, 
#'                          internal_knots, end_time, Warm_block1 = Warm_block1,
#'                          Warm_block2 = Warm_block2)
#' 
#' @export
Sampler_IIGPP <- function(X, n, MCMC_iters, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, Warm_block1 = 500L, Warm_block2 = 2000L, Leapfrog_steps = 10L, I_mean = 40, I_shape = 1, sigma_mean = 6.32, sigma_shape = 1, step_size_theta = 0.001, step_size_FR = 0.001, nu = 5, gamma = 0.25, Mass_adaption_block = 500L, M_proposal = 10L) {
    .Call('_NeuralComp_Sampler_IIGPP', PACKAGE = 'NeuralComp', X, n, MCMC_iters, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, Warm_block1, Warm_block2, Leapfrog_steps, I_mean, I_shape, sigma_mean, sigma_shape, step_size_theta, step_size_FR, nu, gamma, Mass_adaption_block, M_proposal)
}

#' Constructs CI for IIGPP Firing Rate
#' 
#' Constructs credible intervals for the time-inhomgeneous input current function (I) of the inhomogeneous
#' inverse Gaussian point process (IIGPP) model.
#' 
#' @name FR_CI_IIGPP
#' @param time Vector of time points at which pointwise credible intervals will be constructed
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param Results List produced from running \code{Sampler_IIGPP}
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in
#' @param alpha Double indicating the size of the credible interval ((1 - alpha) * 100 percent)
#' 
#' @returns List containing:
#' \describe{
#'   \item{\code{FR_MCMC_Samps}}{Matrix of MCMC samples of the input current function at the specified time points}
#'   \item{\code{FR_CI}}{Matrix containing the upper and lower values of the credible interval at the specified time points (first column is lower value, second column is upper value)}
#'   \item{\code{FR_Median}}{Vector containing the estimated posterior median at the specified time points}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{alpha}}{must be between 0 and 0.5}
#' }
#' 
#' @examples
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots, 
#'                          internal_knots, end_time, Warm_block1 = Warm_block1,
#'                          Warm_block2 = Warm_block2)
#' 
#' ## Get CI
#' time <- seq(0, 1, 0.01)
#' CI <- FR_CI_IIGPP(time, basis_degree, boundary_knots, internal_knots, results)
#' 
#' ## plot CI
#' CI_range <- c(min(CI$FR_CI)-5, max(CI$FR_CI) + 5)
#' plot(time, CI$FR_median, type = 'l', col = "red", ylim = CI_range)
#' lines(time, CI$FR_CI[,1], col = "blue")
#' lines(time, CI$FR_CI[,2], col = "blue")
#' 
#' @export
FR_CI_IIGPP <- function(time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop = 0.3, alpha = 0.05) {
    .Call('_NeuralComp_FR_CI_IIGPP', PACKAGE = 'NeuralComp', time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop, alpha)
}

#' Constructs CI for Competition Firing Rate
#' 
#' Constructs credible intervals for the time-inhomgeneous input current (I) of the 
#' competition model for time-inhomogeneous models.
#' 
#' @name FR_CI_Competition
#' @param time Vector of time points at which pointwise credible intervals will be constructed
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param Results List produced from running \code{Sampler_Competition}
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in
#' @param alpha Double indicating the size of the credible interval ((1 - alpha) * 100 percent)
#' 
#' @returns List containing:
#' \describe{
#'   \item{\code{A_FR_MCMC_Samps}}{Matrix of MCMC samples of the A input current function at the specified time points}
#'   \item{\code{B_FR_MCMC_Samps}}{Matrix of MCMC samples of the B input current function at the specified time points}
#'   \item{\code{A_FR_CI}}{Matrix containing the upper and lower values of the A input current function credible interval at the specified time points (first column is lower value, second column is upper value)}
#'   \item{\code{B_FR_CI}}{Matrix containing the upper and lower values of the B input current function credible interval at the specified time points (first column is lower value, second column is upper value)}
#'   \item{\code{A_FR_Median}}{Vector containing the estimated posterior median A input current function at the specified time points}
#'   \item{\code{B_FR_Median}}{Vector containing the estimated posterior median B input current function at the specified time points}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{alpha}}{must be between 0 and 0.5}
#' }
#' 
#' @examples
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' end_time <- 1
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                end_time, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#' 
#' ## Get CI
#' time <- seq(0, 1, 0.01)
#' CI <- FR_CI_Competition(time, basis_degree, boundary_knots, internal_knots, results)
#' 
#' ## plot A input current CI
#' CI_range <- c(min(CI$A_FR_CI)-5, max(CI$A_FR_CI) + 5)
#' plot(time, CI$A_FR_median, type = 'l', col = "red", ylim = CI_range)
#' lines(time, CI$A_FR_CI[,1], col = "blue")
#' lines(time, CI$A_FR_CI[,2], col = "blue")
#' 
#' ## plot B input current CI
#' CI_range <- c(min(CI$B_FR_CI)-5, max(CI$B_FR_CI) + 5)
#' plot(time, CI$B_FR_median, type = 'l', col = "red", ylim = CI_range)
#' lines(time, CI$B_FR_CI[,1], col = "blue")
#' lines(time, CI$B_FR_CI[,2], col = "blue")
#' 
#' @export
FR_CI_Competition <- function(time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop = 0.3, alpha = 0.05) {
    .Call('_NeuralComp_FR_CI_Competition', PACKAGE = 'NeuralComp', time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop, alpha)
}

#' Calculates WAIC for the Competition Model
#' 
#' This function calculates the Watanabe-Akaike information criterion (WAIC) for 
#' the drift-diffusion competition model using the marginal likelihood (marginalizing out the labels).
#'  This function will use the output from 
#' \code{Sampler_Competition}. The WAIC is defined on the deviance scale as waic = -2(lppd - p),
#' where lppd is the log pointwise predictive density, and p is the effective number of parameters.
#' The Marginal WAIC is akin to leave-one-spike-train-out cross validation (asymptotically).
#' 
#' @name WAIC_Competition
#' @param X_A List of vectors containing the ISIs of A trials
#' @param X_B List of vectors containing the ISIs of B trials
#' @param X_AB List of vectors containing the ISIs of AB trials
#' @param n_A Vector containing number of spikes for each A trial
#' @param n_B Vector containing number of spikes for each B trial
#' @param n_AB Vector containing number of spikes for each AB trial
#' @param Results List produced from running \code{Sampler_Competition}
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @returns List containing:
#' \describe{
#'   \item{\code{WAIC}}{Estimate of WAIC}
#'   \item{\code{LPPD}}{Estimate of LPPD}
#'   \item{\code{Effective_pars}}{Estimated Effective number of parameters}
#'   \item{\code{llik_A}}{Log-likelihood for A trial spike trains}
#'   \item{\code{llik_B}}{Log-likelihood for B trial spike trains}
#'   \item{\code{llik_AB}}{Log-likelihood for AB trial spike trains}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                                time_inhomogeneous = FALSE)
#'                                
#' ## Calculate WAIC
#' WAIC <- WAIC_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB,
#'                          results, basis_degree, boundary_knots, internal_knots, 1,
#'                          time_inhomogeneous = FALSE)
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                Warm_block1 = Warm_block1, Warm_block2 = Warm_block2, 1)
#' 
#' ## Calculate WAIC
#' WAIC <- WAIC_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB,
#'                                   results, basis_degree, boundary_knots, internal_knots, 1)
#' 
#' @export
WAIC_Competition <- function(X_A, X_B, X_AB, n_A, n_B, n_AB, Results, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_WAIC_Competition', PACKAGE = 'NeuralComp', X_A, X_B, X_AB, n_A, n_B, n_AB, Results, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, burnin_prop)
}

#' Calculates WAIC for the IIGPP Model
#' 
#' This function calculates the Watanabe-Akaike information criterion (WAIC) for 
#' the (inhomogeneous) inverse Gaussian point process. This function will use the output from
#' \code{Sampler_IGP} fit for the A, B, and AB data. The WAIC is defined on the 
#' deviance scale as waic = -2(lppd - p), where lppd is the log pointwise 
#' predictive density, and p is the effective number of parameters.
#' 
#' @name WAIC_IIGPP
#' @param X_A List of vectors containing the ISIs of A trials
#' @param X_B List of vectors containing the ISIs of B trials
#' @param X_AB List of vectors containing the ISIs of AB trials
#' @param n_A Vector containing number of spikes for each A trial
#' @param n_B Vector containing number of spikes for each B trial
#' @param n_AB Vector containing number of spikes for each AB trial
#' @param Results_A List produced from running \code{Sampler_IIGPP} for A trials
#' @param Results_B List produced from running \code{Sampler_IIGPP} for B trials
#' @param Results_AB List produced from running \code{Sampler_IIGPP} for AB trials
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @returns List containing:
#' \describe{
#'   \item{\code{WAIC}}{Estimate of WAIC}
#'   \item{\code{LPPD}}{Estimate of LPPD}
#'   \item{\code{Effective_pars}}{Estimated Effective number of parameters}
#'   \item{\code{llik_A}}{Log-likelihood for A trial spike trains}
#'   \item{\code{llik_B}}{Log-likelihood for B trial spike trains}
#'   \item{\code{llik_AB}}{Log-likelihood for AB trial spike trains}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain for A trials
#' results_A <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                            internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                            time_inhomogeneous = FALSE)
#'                        
#' ## Run MCMC chain for B trials
#' results_B<- Sampler_IIGPP(dat$X_B, dat$n_B, MCMC_iters, basis_degree, boundary_knots,
#'                           internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                           time_inhomogeneous = FALSE)
#'
#' ## Run MCMC chain for AB trials
#' results_AB <- Sampler_IIGPP(dat$X_AB, dat$n_AB, MCMC_iters, basis_degree, boundary_knots,
#'                             internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                             time_inhomogeneous = FALSE)         
#' ## Calculate WAIC
#' WAIC <- WAIC_IIGPP(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, results_A,
#'                    results_B, results_AB, basis_degree, boundary_knots, internal_knots,
#'                    time_inhomogeneous = FALSE)
#' 
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain for A trials
#' results_A <- Sampler_IIGPP(dat$X_A, dat$n_A, MCMC_iters, basis_degree, boundary_knots,
#'                            internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#'                        
#' ## Run MCMC chain for B trials
#' results_B<- Sampler_IIGPP(dat$X_B, dat$n_B, MCMC_iters, basis_degree, boundary_knots,
#'                           internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#'
#' ## Run MCMC chain for AB trials
#' results_AB <- Sampler_IIGPP(dat$X_AB, dat$n_AB, MCMC_iters, basis_degree, boundary_knots,
#'                             internal_knots, Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#'
#' WAIC <- WAIC_IIGPP(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, results_A,
#'                    results_B, results_AB, basis_degree, boundary_knots, internal_knots)
#' 
#' @export
WAIC_IIGPP <- function(X_A, X_B, X_AB, n_A, n_B, n_AB, Results_A, Results_B, Results_AB, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_WAIC_IIGPP', PACKAGE = 'NeuralComp', X_A, X_B, X_AB, n_A, n_B, n_AB, Results_A, Results_B, Results_AB, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, burnin_prop)
}

WAIC_Winner_Take_All <- function(X_A, X_B, n_A, n_B, Results_A, Results_B, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_WAIC_Winner_Take_All', PACKAGE = 'NeuralComp', X_A, X_B, n_A, n_B, Results_A, Results_B, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, burnin_prop)
}

#' Posterior Predictive Sampling for Competition Model
#' 
#' This function generates posterior predictive samples of scientific interest from
#' the competition model. Specifically, this function allows you to obtain (1) posterior
#' predictive samples from the A condition, B condition, and AB conditions (2) posterior
#' predictive samples of spike counts under the A condition, B condition, and AB conditions, 
#' (3) posterior predictive samples of time spent encoding each state (4) posterior predictive 
#' samples for the number of switches in a trial. This function is to be used after running
#' \code{Sampler_Competition}.
#' 
#' @name Competition_Posterior_Predictive
#' @param trial_time Double containing length of trial to simulate
#' @param basis_degree Integer indicating the degree of B-splines (3 for cubic splines)
#' @param boundary_knots Vector of two elements specifying the boundary knots
#' @param internal_knots Vector containing the desired internal knots of the B-splines
#' @param Results List produced from running \code{Sampler_Competition}
#' @param burnin_prop Double containing proportion of MCMC samples that should be discarded due to MCMC burn-in (Note burnin_prop includes warm-up iterations)
#' @param time_inhomogeneous Boolean containing whether or not a time-inhomogeneous model should be used (if false then basis_degree, boundary_knots, and internal_knots can take any value of the correct type)
#' @param n_samples Integer containing number of posterior predictive samples to generate
#' @returns List containing:
#' \describe{
#'   \item{\code{posterior_pred_samples_A}}{Posterior predictive samples of spike trains under the A stimulus}
#'   \item{\code{posterior_pred_samples_B}}{Posterior predictive samples of spike trains under the B stimulus}
#'   \item{\code{posterior_pred_samples_AB}}{Posterior predictive samples of spike trains under the A  and B stimuli}
#'   \item{\code{posterior_pred_labels}}{labels corresponding to posterior_pred_samples_AB}
#'   \item{\code{n_A}}{Number of spikes in each of the spike trains in posterior_pred_samples_A}
#'   \item{\code{n_B}}{Number of spikes in each of the spike trains in posterior_pred_samples_B}
#'   \item{\code{n_AB}}{Number of spikes in each of the spike trains in posterior_pred_samples_AB}
#'   \item{\code{switch_times}}{Times spent in each encoding state in the spike trains generated in posterior_pred_samples_AB}
#'   \item{\code{switch_states}}{Encoding state (labels) corresponding to switch_times}
#'   \item{\code{n_switches}}{number of switches observed in each spike train generated in posterior_pred_samples_AB}
#' }
#' 
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{burnin_prop}}{must be greater than or equal to 0 and less than 1}
#'   \item{\code{n_sample}}{must be greater than 1}
#' }
#' 
#' @examples
#' ##############################
#' ### Time-Homogeneous Model ###
#' ##############################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_homogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' 
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                Warm_block1 = Warm_block1, Warm_block2 = Warm_block2,
#'                                time_inhomogeneous = FALSE)
#'                                
#' ## Posterior Predictive Samples
#' post_pred <- Competition_Posterior_Predictive(1, basis_degree, boundary_knots, internal_knots,
#'                                               results, time_inhomogeneous = FALSE)
#' 
#' ################################
#' ### Time-Inhomogeneous Model ###
#' ################################
#' 
#' ## Load sample data
#' dat <- readRDS(system.file("test-data", "time_inhomogeneous_sample_dat.RDS", package = "NeuralComp"))
#' 
#' ## set parameters
#' MCMC_iters <- 100
#' basis_degree <- 3
#' boundary_knots <- c(0, 1)
#' internal_knots <- c(0.25, 0.5, 0.75)
#' 
#' ## Warm Blocks should be longer, however for the example, they are short
#' Warm_block1 = 50
#' Warm_block2 = 50
#' 
#' ## Run MCMC chain
#' results <- Sampler_Competition(dat$X_A, dat$X_B, dat$X_AB, dat$n_A, dat$n_B, dat$n_AB, 
#'                                MCMC_iters, basis_degree, boundary_knots, internal_knots,
#'                                Warm_block1 = Warm_block1, Warm_block2 = Warm_block2)
#'                                
#' ## Posterior Predictive Samples                               
#' post_pred <- Competition_Posterior_Predictive(1, basis_degree, boundary_knots, internal_knots,
#'                                               results)
#'                                               
#' @export
Competition_Posterior_Predictive <- function(end_time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop = 0.2, time_inhomogeneous = TRUE, n_samples = 10000L) {
    .Call('_NeuralComp_Competition_Posterior_Predictive', PACKAGE = 'NeuralComp', end_time, basis_degree, boundary_knots, internal_knots, Results, burnin_prop, time_inhomogeneous, n_samples)
}

Diff_LLPD <- function(X_A, X_B, n_A, n_B, Results_A, Results_B, Results_joint, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_Diff_LLPD', PACKAGE = 'NeuralComp', X_A, X_B, n_A, n_B, Results_A, Results_B, Results_joint, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, burnin_prop)
}

Test_IIGPP_Fit <- function(X, n, Results, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous = TRUE, burnin_prop = 0.2) {
    .Call('_NeuralComp_Test_IIGPP_Fit', PACKAGE = 'NeuralComp', X, n, Results, basis_degree, boundary_knots, internal_knots, end_time, time_inhomogeneous, burnin_prop)
}

rcpparma_hello_world <- function() {
    .Call('_NeuralComp_rcpparma_hello_world', PACKAGE = 'NeuralComp')
}

rcpparma_outerproduct <- function(x) {
    .Call('_NeuralComp_rcpparma_outerproduct', PACKAGE = 'NeuralComp', x)
}

rcpparma_innerproduct <- function(x) {
    .Call('_NeuralComp_rcpparma_innerproduct', PACKAGE = 'NeuralComp', x)
}

rcpparma_bothproducts <- function(x) {
    .Call('_NeuralComp_rcpparma_bothproducts', PACKAGE = 'NeuralComp', x)
}

dinv_gauss <- function(x, mean, shape) {
    .Call('_NeuralComp_dinv_gauss', PACKAGE = 'NeuralComp', x, mean, shape)
}

pinv_gauss <- function(x, mean, shape) {
    .Call('_NeuralComp_pinv_gauss', PACKAGE = 'NeuralComp', x, mean, shape)
}

dnorm_test <- function(prop_momentum) {
    .Call('_NeuralComp_dnorm_test', PACKAGE = 'NeuralComp', prop_momentum)
}

